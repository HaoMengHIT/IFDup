//-----Developed by Jing Yu -----//
//This file is extracted from ParIFDuplica.cpp //
//for reading purpose. It can stand alone by itself//
//

#include <llvm/IR/Instruction.h>
#include <llvm/IR/BasicBlock.h>
using namespace std;

void ParIFDuplica::DupImplement(std::list<ChildrenSet*> *HeadNodeList){
    std::list<ChildrenSet*>::iterator iter;
    ChildrenSet * SCHead;

    //initialize a map that associates "global" value and its duplica
    std::map<Value*,Value*> valueMap;
    valueMap.clear();

    for (iter=HeadNodeList->begin(); iter!=HeadNodeList->end(); iter++) {
	SCHead = (*iter);
	std::set<ChildrenSet*>*midnodeset = SCHead->getSCmidnodeset();

	//find a proper position inside SCHead to duplicate all variables that were used by this set but were generated by previous blocks
	Instruction *HeadInsertBF = findPosin(SCHead);

	//work through midnodeset. The access order is not important.
	std::list<ChildrenSet*>WorkList;
	WorkList.push_front(SCHead);
	std::set<ChildrenSet*>::iterator miditer;

	//Preprocess all BasicBlock contents
	//And intitiate working list for edges scan
	preRepBlock(SCHead->getBB(),valueMap,HeadInsertBF);

	for (miditer=midnodeset->begin(); miditer!=midnodeset->end(); miditer++) {
	    preRepBlock((*miditer)->getBB(),valueMap,HeadInsertBF);
	    WorkList.push_back(*miditer);
	}
	
	//Scan all edges
	while (!WorkList.empty()) {
	    ChildrenSet* thisnode = WorkList.front();
	    WorkList.pop_front();

	    //work on out1 edge
	    ImplementonEdge(thisnode->out0,0,valueMap,HeadInsertBF);

	    //work on out2 edge
	    ImplementonEdge(thisnode->out1,1,valueMap,HeadInsertBF);

	}
    }//end of for
}


//find a proper position in head where to insert assignment
Instruction *ParIFDuplica::findPosin(ChildrenSet *HeadNode) {
	assert(HeadNode->isHead() && "Error:findPosin() can only be called on head node!");
	BasicBlock *headBB = HeadNode->getBB();
	BasicBlock::iterator pointer = --headBB->end();
	//Instruction *pointer = &(headBB->back());
	if (pointer == headBB->begin()) return pointer; //if only one instruction
	while ((pointer!=headBB->begin() ) && (noEffect(pointer)))
		--pointer;

	if (noEffect(pointer)) return pointer;
	else return ++pointer;
}

//check if inst generate a value that will be used by other block 
//or in a phi node
//Mimic valueEscapes(Instruction*) in Reg2Mem.cpp except the memory part
bool ParIFDuplica::noEffect(Instruction *i) {
    if (i->mayWriteToMemory() || isa<PHINode>(i) ) return false;
    BasicBlock *bb = i->getParent();
    for (Value::use_iterator ii = i->use_begin(), ie=i->use_end(); ii!=ie; ++ii)
	if (cast<Instruction>(*ii)->getParent() != bb ||
	    isa<PHINode>(*ii))
	    return false;
    return true;
}

//Implement duplication on the edge
bool ParIFDuplica::ImplementonEdge(Edge *theEdge,unsigned int fromOP,std::map<Value*,Value*>&valueMap,Instruction *HeadInsertBF ) {

    //get Rep on that edge
    std::list<Rep*> *RepList = theEdge->getfinalRep();
    if (RepList->empty()) return false; //no need to update the link

    NumReplicatedBB += RepList->size();
    localnumreplicatedBB += RepList->size();

    BasicBlock *fromBB = theEdge->getFrom()->getBB();
    BasicBlock *toBB = theEdge->getTo();

    BranchInst *fromBBBranchI = dyn_cast<BranchInst>(fromBB->getTerminator());
    assert((fromBBBranchI->getSuccessor(fromOP) == toBB) && "Error: SC construction is corrupted");

    BasicBlock *currentBBlink = fromBB;
    BranchInst *currentBI = fromBBBranchI;

    std::list<Rep*>::iterator RepListiter;
    for (RepListiter = RepList->begin(); RepListiter != RepList->end(); RepListiter++) {
	Rep *thisRep = *RepListiter;
	BasicBlock *BBtobeDup = thisRep->getBB();

	//make a dup of BBtobeDup
	BasicBlock *DupBB = RepBlock(BBtobeDup,valueMap,HeadInsertBF,toBB);

	//link currentBBlink (operand) to CloneBB
	currentBI->setSuccessor(fromOP,DupBB);

	//update currentBBlink and curentBI
	currentBBlink = DupBB;
	currentBI = dyn_cast<BranchInst>(currentBBlink->getTerminator());
	assert(currentBI && "Error: last instruction must be a terminator");

	//set CloneBB's outgoing edge that points to ERROR block
	unsigned int correctBranch = (thisRep->getOntrueside()?0:1);
	unsigned int errorBranch = (correctBranch==0?1:0);
	setbranchtoError(currentBI, errorBranch);
	
	fromOP = correctBranch;
    }

    //link currentBBlink to toBB
    currentBI->setSuccessor(fromOP,toBB);
    //if toBB has PhINode
    if (isa<PHINode>(toBB->begin())) UpdateIncomeSource(toBB,fromBB,currentBBlink);
    return true;

}

//duplicate this BB, place it before beforeBB, return it
//The branch targets are left uncared
BasicBlock * ParIFDuplica::RepBlock(BasicBlock *thisBB,std::map<Value*,Value*>&valueMap,Instruction* HeadInsertBF, BasicBlock *beforeBB)
{
	std::map<Value*,Value*> localMap;
	std::string newName = thisBB->getName().str()+"_dup_"+ beforeBB->getName().str();

	BasicBlock *newBB = BasicBlock::Create(thisBB->getContext(), newName, thisBB->getParent(),beforeBB);

	Instruction* Inst;
	if ((HeadInsertBF->getParent()) == thisBB) Inst = HeadInsertBF;
	else Inst = thisBB->begin();

	while(Inst!=&thisBB->back()) {
		assert(!isa<AllocaInst>(Inst) && "Should not have AllocaInst replicated");
		Instruction *newI = Inst->clone();
		if (Inst->hasName())
			newI->setName(Inst->getName() + "_dup");
		//repliace its operands
		replaceOperands(newI, valueMap, localMap);
		//update localMap
		localMap[Inst]=newI;
		//push NewI to the back of newBB
		newBB->getInstList().push_back(newI);
		Inst = Inst->getNextNode();
	};
	assert(Inst->isTerminator() && "Error:the last should be a terminator");

	//duplicate the last instruction
	BranchInst *newBranchI = cast<BranchInst>(Inst->clone());
	if (Inst->hasName()) 
		newBranchI->setName(Inst->getName() + "_dup");

	assert(newBranchI->isConditional() && "Error: the terminator must be a conditional branch");
	Value *cond = newBranchI->getCondition();
	Value *repcond = NULL;
	if (localMap.count(cond)>0) repcond = localMap[cond];
	else if (valueMap.count(cond)>0) repcond = valueMap[cond];

	if (repcond) newBranchI->setCondition(repcond);
	else {
		Instruction *condI = cast<Instruction>(cond);
		assert(condI && "Branch condition must be an instruction");
		assert(!canbecopied(condI) && "This cond can not be copied");
	}
	newBB->getInstList().push_back(newBranchI);

	return newBB;
}


//Duplicate all outside values that are used by thisBB
//If thisBB is head, we only process instructions after HeadInsertBF
void ParIFDuplica::preRepBlock(BasicBlock *thisBB,std::map<Value*,Value*>&valueMap, Instruction* HeadInsertBF){
	BasicBlock::iterator myscan= thisBB->begin();
	bool isHead;
	std::set<Instruction*> notWorkzone;

	//There should be no Phi node for non-head node
	if (HeadInsertBF->getParent()!=thisBB) {
		isHead = false;
		assert(!isa<PHINode>(thisBB->begin()) && "Error:midnodes should not have Phi");
	} else {
		isHead = true;
		//add instructions before HeadInsertBF to notWorkzone
		while (&*myscan != HeadInsertBF) {
			notWorkzone.insert(myscan);
			++myscan;
		}
		assert(!isa<PHINode>(myscan) && "HeadInsertBF should not point to a PHI");
	}
#ifdef Jing_DEBUG
	//    std::cerr << "PreRep Block " << thisBB->getName() <<" :---\n";
#endif
	//scan instructions in workzone. Do not need to care about the 
	//last instruction, because it must be a terminator.
	while (myscan != thisBB->end()) { 
		if (myscan->isTerminator()) break;
		unsigned int numOP = myscan->getNumOperands();
		for (unsigned int i=0; i < numOP; i++) {
			//for each outside operand, check it has been duplicated before
			// (has an entry in valueMap)
			Instruction *curOP = dyn_cast<Instruction>(myscan->getOperand(i));
			//operand is not always an instruction, but we can only work on instruction
			//assert(curOP && "Error:operand should be an instruction");
			if (curOP && canbecopied(curOP)) {
				//check if curOP was defined in other BB or in notWorkzone
				if (curOP->getParent() != thisBB || notWorkzone.count(curOP)>0) {
					//check if curOP was duplicated before
					if (valueMap.count(curOP)==0) {
						//make a copy of curOP
						Instruction *newcurOP = curOP->clone();
						newcurOP->setName(curOP->getName()+"_dup");
#ifdef Jing_DEBUG
						//std::cerr<<"Rep " <<curOP->getName() << " to " <<newcurOP->getName() <<" \n";
#endif
						//hope this works
						curOP->getParent()->getInstList().insert(curOP,newcurOP);
						valueMap[curOP]=newcurOP;
					}
				}
			}
#ifdef Jing_DEBUG
			else {

			}
#endif
		} //end of for
		++myscan;
	} //end of while
	//we also need to care about condition of branchInst
	BranchInst *branchI = dyn_cast<BranchInst>(myscan);
	assert(branchI && "the last instruction must be a branch");
	Instruction *cond = dyn_cast<Instruction>(branchI->getCondition());
	assert(cond && "branch condition must be an instruction");
	//check if cond should be replicated in preRep pass
	if (cond->getParent() != thisBB || notWorkzone.count(cond)>0) {
		if (valueMap.count(cond)==0 && canbecopied(cond)) {
			Instruction *newcond = cond->clone();
			newcond->setName(cond->getName()+"_dup");
			cond->getParent()->getInstList().insert(cond,newcond);
			valueMap[cond]=newcond;
		}
	}
}


void ParIFDuplica::replaceOperands(Instruction *newI,std::map<Value*,Value*>&valueMap,std::map<Value*,Value*>&localMap){
    unsigned int numOP = newI->getNumOperands();
    for (unsigned int i=0; i<numOP; i++) {
	Value *curOP = newI->getOperand(i);
	if (valueMap.count(curOP)>0) 
	    newI->setOperand(i,valueMap[curOP]);
	else if (localMap.count(curOP)>0)
	    newI->setOperand(i,localMap[curOP]);
	//if the operand does not have a value in maps, it means the operand is not an instruction or failed canbecopied test
        else assert((!isa<Instruction>(curOP)||!canbecopied(cast<Instruction>(curOP))) && "the operand should have a map in valuemap or localmap");
    }

}


void ParIFDuplica::setbranchtoError(BranchInst *currentBI, unsigned int errorBranch) {
    assert(errorBlock);
    currentBI->setSuccessor(errorBranch,errorBlock);
}


void ParIFDuplica::UpdateIncomeSource(BasicBlock *BB,BasicBlock *changefrom,BasicBlock* changeto){
    for (BasicBlock::iterator iter = BB->begin(), iterend = BB->end(); iter!=iterend; iter++) {
	if (PHINode *PN = dyn_cast<PHINode>(iter)) {
	    bool changed = false;
	    for (unsigned i = 0, e=PN->getNumIncomingValues(); i!=e;++i)
		//replace the incoming block of changefrom by changeto
		if (PN->getIncomingBlock(i)==changefrom) {
		    PN->setIncomingBlock(i,changeto);
		    changed = true;
		}
	    assert(changed && "Error:changefrom should appear in every PHI node");
	}
    }
}


bool ParIFDuplica::canbecopied(Instruction *I) {
   if (I->mayWriteToMemory() || isa<PHINode>(I) || isa<AllocaInst>(I) ) return false;
	if (CallInst* CI = dyn_cast<CallInst>(I))
		if(CI->getCalledValue()->getName()=="malloc") 
			return false;
   return true;
	//return false;
}
