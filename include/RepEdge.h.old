//-----Developed by Jing Yu-----//
//RepEdge.h                     //
//-------------------------------//
//This is the head file to define //
//    Rep class                    //
//    Edge class                //
//================================//

#ifndef REPEDGE_H
#define REPEDGE_H

#include "llvm/Pass.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Transforms/Utils/Local.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/Function.h"
#include "llvm/Instructions.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/Analysis/Dominators.h"
//#include "llvm/Support/Debug.h"

#include "ShortcutDetector.h"
#include <list>
#include <string>


using namespace llvm;

namespace {
    struct ChildrenSet;

    struct Rep {
	Rep(BasicBlock *baseBB, bool trueside) {
	    mybaseBB = baseBB;
	    isOntrueside = trueside;
	    mynotTo = NULL;
	}

	Rep(BasicBlock *baseBB, bool trueside, BasicBlock* notTo) {
	    mybaseBB = baseBB;
	    isOntrueside = trueside;
	    mynotTo = notTo;
	}
	/* --ugly. hope it will not be used
	Rep(Rep &duplica) {
	    mybaseBB = duplica.getBB();
	    isOntrueside = duplica.getOntrueside();
	    mynotTo = duplica.getnotTo();
	}
	*/
    private:
	BasicBlock *mybaseBB; //BB to be replicated
	bool isOntrueside; //if this replica is on true side
	BasicBlock *mynotTo; //not propagate to the edge that has notTo as destination

    public:
	bool getOntrueside() {return isOntrueside;}
	BasicBlock *getnotTo(){return mynotTo;}
	BasicBlock *getBB() {return mybaseBB;}

        bool notTo(BasicBlock *target) {return (mynotTo == target);}
	bool notTo(ChildrenSet *target);

	std::string dump() {
	    std::string s;
	    s+="Rep("+mybaseBB->getName()+",";
	    s+=(isOntrueside?"T,":"F,");
	    if (mynotTo) s+="Not("+mynotTo->getName()+")";
	    return s;
	}
    }; //end of struct Rep


    ///////////////////////////////////////
    ///////////////////////////////////////   
 struct Edge {
     Edge(ChildrenSet *from, BasicBlock *to) {fromNode = from; toNode = to;}
     Edge(ChildrenSet *from, ChildrenSet *to);

    private:
      ChildrenSet *fromNode;
      BasicBlock *toNode;
      std::list<Rep*> propgtRep;
      std::list<Rep*> fixRep;

    public:
      Rep* popFirstRep() { 
	  Rep *firstone = propgtRep.front();
	  propgtRep.pop_front();
	  return firstone;
      }
     void insertRep(Rep *one) { //insert to fixRep
	 fixRep.push_back(one);
     }
     void propagateTo(Rep *one) { //propagate to propgtRep
	 if (!one->notTo(toNode)) { //this edge can be propagated to
	     propgtRep.push_back(one);
	 }
     }
     bool isPRepEmpty() {return propgtRep.empty();}
     bool isFRepEmpth() {return fixRep.empty();}

     std::list<Rep*> getfinalRep() {
	 assert(propgtRep.empty() && "getfinalRep must be called after all propagation is done!");
	 fixRep.unique();
	 return fixRep;
     }

     std::string dump();

     std::string dump(std::list<Rep*> &listtodump) {
	 if (listtodump.empty()) return " ";

	 std::string *s = new std::string();
	 std::list<Rep*>::iterator iter;
	 for (iter=listtodump.begin(); iter!=listtodump.end(); iter++) {
	     (*s)+=(*iter)->dump()+" ";
	 }
	 return (*s);
     }

    };//end of struct Edge

}



bool 
Rep::notTo(ChildrenSet *target) {return (mynotTo == target->getBB());}

Edge::Edge(ChildrenSet *from, ChildrenSet *to) {
    fromNode = from; toNode = to->getBB();
}


std::string 
Edge::dump() {
	 std::string s;
	 s = "Edge("+ fromNode->getBB()->getName()+"->"+toNode->getName()+")\n";
	 s+="propgtRep:"+dump(propgtRep)+";";
	 s+="fixRep:"+dump(fixRep)+"\n";
	 return s;

     }


#endif
